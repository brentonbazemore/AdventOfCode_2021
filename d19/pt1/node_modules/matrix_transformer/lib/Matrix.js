"use strict";

function Matrix(coordinates) {
  this.x = coordinates.x;
  this.y = coordinates.y;
  this.z = coordinates.z;
};

Matrix.prototype.loopCounter = 0;

Matrix.prototype.value = function () {
  return [[this.x], [this.y], [this.z], [1]];
};

Matrix.prototype.scaleX = function (scalarX) {
  var newValues = this._multiplyMatrices([[scalarX, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.scaleY = function (scalarY) {
  var newValues = this._multiplyMatrices([[1, 0, 0, 0], [0, scalarY, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.scaleZ = function (scalarZ) {
  var newValues = this._multiplyMatrices([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, scalarZ, 0], [0, 0, 0, 1]], this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.translateX = function (offsetX) {
  var newValues = this._multiplyMatrices([[1, 0, 0, offsetX], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.translateY = function (offsetY) {
  var newValues = this._multiplyMatrices([[1, 0, 0, 0], [0, 1, 0, offsetY], [0, 0, 1, 0], [0, 0, 0, 1]], this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.translateZ = function (offsetZ) {
  var newValues = this._multiplyMatrices([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, offsetZ], [0, 0, 0, 1]], this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.rotateZ = function (theta) {
  var trig = this._degreesToTrigVals({ x: 0, y: 0, z: theta });
  var newRotationMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
  newRotationMatrix[0][0] = parseFloat(trig.gamma.cos.toFixed(3));
  newRotationMatrix[0][1] = parseFloat(-trig.gamma.sin.toFixed(3));
  newRotationMatrix[1][0] = parseFloat(trig.gamma.sin.toFixed(3));
  newRotationMatrix[1][1] = parseFloat(trig.gamma.cos.toFixed(3));

  var newValues = this._multiplyMatrices(newRotationMatrix, this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.rotateY = function (theta) {
  var trig = this._degreesToTrigVals({ x: 0, y: theta, z: 0 });
  var newRotationMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
  newRotationMatrix[0][0] = parseFloat(trig.beta.cos.toFixed(3));
  newRotationMatrix[0][2] = parseFloat(trig.beta.sin.toFixed(3));
  newRotationMatrix[2][0] = parseFloat(-trig.beta.sin.toFixed(3));
  newRotationMatrix[2][2] = parseFloat(trig.beta.cos.toFixed(3));

  var newValues = this._multiplyMatrices(newRotationMatrix, this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.rotateX = function (theta) {
  var trig = this._degreesToTrigVals({ x: theta, y: 0, z: 0 });
  var newRotationMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
  newRotationMatrix[1][1] = parseFloat(trig.alpha.cos.toFixed(3));
  newRotationMatrix[1][2] = parseFloat(-trig.alpha.sin.toFixed(3));
  newRotationMatrix[2][1] = parseFloat(trig.alpha.sin.toFixed(3));
  newRotationMatrix[2][2] = parseFloat(trig.alpha.cos.toFixed(3));

  var newValues = this._multiplyMatrices(newRotationMatrix, this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.translate = function (offsets) {
  var newValues = this._multiplyMatrices([[1, 0, 0, offsets.x], [0, 1, 0, offsets.y], [0, 0, 1, offsets.z], [0, 0, 0, 1]], this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.scale = function (scalars) {
  var newValues = this._multiplyMatrices([[scalars.x, 0, 0, 0], [0, scalars.y, 0, 0], [0, 0, scalars.z, 0], [0, 0, 0, 1]], this.value());
  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.rotateXYZ = function (degrees) {
  var rotationMatrix = this._getXYZRotationMatrix(degrees);

  var newValues = this._multiplyMatrices(rotationMatrix, this.value());

  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.rotateZYX = function (degrees) {
  var rotationMatrix = this._getZYXRotationMatrix(degrees);

  var newValues = this._multiplyMatrices(rotationMatrix, this.value());

  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype.move = function (translate, scale, rotation, origin) {
  var newValues = this.value();
  if (!origin) {
    origin = { x: 0, y: 0, z: 0 };
  }
  newValues = this._multiplyMatrices([[1, 0, 0, origin.x], [0, 1, 0, origin.y], [0, 0, 1, origin.z], [0, 0, 0, 1]], newValues); // Translate to new origin
  newValues = this._multiplyMatrices([[scale.x, 0, 0, 0], [0, scale.y, 0, 0], [0, 0, scale.z, 0], [0, 0, 0, 1]], newValues); // Scale at new origin
  newValues = this._multiplyMatrices(this._getXYZRotationMatrix(rotation), newValues);
  newValues = this._multiplyMatrices([[1, 0, 0, -origin.x], [0, 1, 0, -origin.y], [0, 0, 1, -origin.z], [0, 0, 0, 1]], newValues);
  newValues = this._multiplyMatrices([[1, 0, 0, translate.x], [0, 1, 0, translate.y], [0, 0, 1, translate.z], [0, 0, 0, 1]], newValues);

  return new Matrix({ x: newValues[0][0], y: newValues[1][0], z: newValues[2][0] });
};

Matrix.prototype._getXYZRotationMatrix = function (degrees) {
  var trig = this._degreesToTrigVals(degrees);
  var newRotationMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
  newRotationMatrix[0][0] = parseFloat((trig.beta.cos * trig.gamma.cos).toFixed(3));
  newRotationMatrix[1][0] = parseFloat((trig.beta.cos * trig.gamma.sin).toFixed(3));
  newRotationMatrix[2][0] = parseFloat((-trig.beta.sin).toFixed(3));

  newRotationMatrix[0][1] = parseFloat((trig.gamma.cos * trig.alpha.sin * trig.beta.sin - trig.alpha.cos * trig.gamma.sin).toFixed(3));
  newRotationMatrix[1][1] = parseFloat((trig.alpha.cos * trig.gamma.cos + trig.alpha.sin * trig.beta.sin * trig.gamma.sin).toFixed(3));
  newRotationMatrix[2][1] = parseFloat((trig.beta.cos * trig.alpha.sin).toFixed(3));

  newRotationMatrix[0][2] = parseFloat((trig.alpha.cos * trig.gamma.cos * trig.beta.sin + trig.alpha.sin * trig.gamma.sin).toFixed(3));
  newRotationMatrix[1][2] = parseFloat((-trig.gamma.cos * trig.alpha.sin + trig.alpha.cos * trig.beta.sin * trig.gamma.sin).toFixed(3));
  newRotationMatrix[2][2] = parseFloat((trig.alpha.cos * trig.beta.cos).toFixed(3));
  return newRotationMatrix;
};

Matrix.prototype._getZYXRotationMatrix = function (degrees) {
  var trig = this._degreesToTrigVals(degrees);
  var newRotationMatrix = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]];
  newRotationMatrix[0][0] = parseFloat((trig.beta.cos * trig.gamma.cos).toFixed(3));
  newRotationMatrix[1][0] = parseFloat((trig.alpha.cos * trig.gamma.sin + trig.alpha.sin * trig.beta.sin * trig.gamma.cos).toFixed(3));
  newRotationMatrix[2][0] = parseFloat((trig.alpha.sin * trig.gamma.sin - trig.alpha.cos * trig.beta.sin * trig.gamma.cos).toFixed(3));

  newRotationMatrix[0][1] = parseFloat((-trig.beta.cos * trig.gamma.sin).toFixed(3));
  newRotationMatrix[1][1] = parseFloat((trig.alpha.cos * trig.gamma.cos - trig.alpha.sin * trig.beta.sin * trig.gamma.sin).toFixed(3));
  newRotationMatrix[2][1] = parseFloat((trig.alpha.sin * trig.gamma.cos + trig.alpha.cos * trig.beta.sin * trig.gamma.sin).toFixed(3));

  newRotationMatrix[0][2] = parseFloat(trig.beta.sin.toFixed(3));
  newRotationMatrix[1][2] = parseFloat((-trig.alpha.sin * trig.beta.cos).toFixed(3));
  newRotationMatrix[2][2] = parseFloat((trig.alpha.cos * trig.beta.cos).toFixed(3));

  return newRotationMatrix;
};

Matrix.prototype.toObject = function () {
  return { x: this.x, y: this.y, z: this.z };
};

Matrix.prototype._degreesToTrigVals = function (angles) {
  return {
    alpha: {
      sin: Math.sin(this._degreesToRadians(angles.x)),
      cos: Math.cos(this._degreesToRadians(angles.x)),
      tan: Math.tan(this._degreesToRadians(angles.x))
    },
    beta: {
      sin: Math.sin(this._degreesToRadians(angles.y)),
      cos: Math.cos(this._degreesToRadians(angles.y)),
      tan: Math.tan(this._degreesToRadians(angles.y))
    },
    gamma: {
      sin: Math.sin(this._degreesToRadians(angles.z)),
      cos: Math.cos(this._degreesToRadians(angles.z)),
      tan: Math.tan(this._degreesToRadians(angles.z))
    }
  };
};

Matrix.prototype._degreesToRadians = function (degrees) {
  return degrees * (Math.PI / 180);
};

Matrix.prototype._multiplyMatrices = function (a, b) {
  var aRows = a.length;
  var aCols = a[0].length;
  var bRows = b.length;
  var bCols = b[0].length;
  var m = new Array(aRows); // initialize array 

  if (aCols != bRows) {
    return;
  }

  for (var i = 0; i < aRows; i++) {
    m[i] = new Array(bCols);
    for (var j = 0; j < bCols; j++) {

      var sum = 0;
      for (var k = 0; k < aCols; k++) {
        this.loopCounter++;
        sum += a[i][k] * b[k][j];
      }
      m[i][j] = sum;
    }
  }
  return m;
};

module.exports = Matrix;