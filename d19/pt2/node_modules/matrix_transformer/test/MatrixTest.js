var Chai = require('chai');
var expect = Chai.expect;

var Matrix = require('../index');

describe("MATRIX MANIPULATOR", function() {
    var matrix;
    var mat;
    beforeEach(function() {
        matrix = new Matrix({x: 1,y: 2,z: 3});
    });

    afterEach(function() {
        mat = null;        
    });
        
    describe("constructor", function() {
        it("should create a new instance of a matrix", function() {
            expect(matrix).to.exist;
            expect(typeof(matrix)).to.equal('object');
            expect(matrix instanceof Matrix).to.equal(true);
        });

        it("should populate the coordinates with the passed in values", function() {
            expect(matrix.x).to.equal(1);
            expect(matrix.y).to.equal(2);
            expect(matrix.z).to.equal(3);
        });
    });

    describe("multiply matrices function", function() {
        it("should only succeed if matrices are of correct dimensions", function() {
            expect(matrix._multiplyMatrices([[2],[3]], [[2],[3]])).to.not.exist;
        });

        it("should apply product multiplication to two matrices", function() {
            expect(matrix._multiplyMatrices([[2],[3]],[[2,3]])).to.eql([[4,6], [6,9]]);
        });
    });
    
    describe("matrix scaling", function() {
        it("should scale in the x direction based on the x scaling factor",function() {
            var mat = matrix.scaleX(5).toObject();
            expect(mat).to.eql({x: 5,y: 2,z: 3});
        });

        it("should scale in the x directions for a negative", function() {
            mat = matrix.scaleX(-1).toObject();
            expect(mat).to.eql({x: -1, y: 2, z: 3});
        });

        it("should scale in the y direction", function() {
            mat = matrix.scaleY(5).toObject();
            expect(mat).to.eql({x: 1, y: 10, z: 3});
        });

        it("should scale with decimal value", function() {
            mat = matrix.scaleX(0.5).toObject();
            expect(mat).to.eql({x: 0.5, y: 2,z: 3});
        });

        it("should scale in the z direction", function() {
            mat = matrix.scaleZ(10).toObject();
            expect(mat).to.eql({x: 1, y: 2, z: 30});
        });

        it("should be composable for multiple scaling functions", function() {
            mat = matrix.scaleX(5).scaleY(5).scaleZ(10).toObject();
            expect(mat).to.eql({x: 5, y: 10, z: 30});
        });

        it("should retain the values across multiple operations", function() {
            mat = matrix.scaleX(10);
            mat = mat.scaleZ(10);
            mat = mat.scaleY(10).toObject();
            
            expect(mat).to.eql({x: 10, y: 20, z: 30});
        });
    });
    
    describe("matrix translation", function() {
        it("should translate in the positive x direction", function() {
            mat = matrix.translateX(10).toObject();
            expect(mat).to.eql({x: 11, y: 2, z: 3});
        });

        it("should scale x in the negative direction", function() {
            mat = matrix.translateX(-10).toObject();
            expect(mat).to.eql({x: -9, y: 2, z: 3});
        });

        it("should be composable for multiple x translations", function() {
            mat = matrix.translateX(10).translateX(-5).toObject();
            expect(mat).to.eql({x: 6, y: 2, z: 3});
        });

        it("should translate in the positive y direction", function() {
            mat = matrix.translateY(10).toObject();
            expect(mat).to.eql({x: 1, y: 12, z: 3});
        });

        it("should translate in the negative y direction", function() {
            mat = matrix.translateY(-10).toObject();
            expect(mat).to.eql({x: 1, y: -8, z: 3});
        });

        it("should translate in the positive z direction", function() {
            mat = matrix.translateZ(10).toObject();
            expect(mat).to.eql({x: 1, y: 2, z: 13});
        });

        it("should translate in the negative z direction", function() {
            mat = matrix.translateZ(-10).toObject();
            expect(mat).to.eql({x: 1, y: 2, z: -7});
        });

        it("should be composable when scaling multiple axes", function() {
            mat = matrix.translateX(10).translateY(10).translateZ(10).toObject();
            expect(mat).to.eql({x: 11, y: 12, z: 13});
        });

        it("should retain results across multiple translation operations", function() {
            mat = matrix.translateX(10)
                    .translateX(10)
                    .translateY(10)
                    .translateZ(10)
                    .translateY(-20)
                    .toObject();

            expect(mat).to.eql({x: 21,y: -8,z: 13});
        });
    });

    describe("matrix rotation", function() {
        it("should rotate about the z axis", function() {
            mat = matrix.rotateZ(90).toObject();
            expect(mat).to.eql({x: -2, y: 1, z: 3});
        });

        it("should be composable with scaling operations", function() {
            mat = matrix.rotateZ(90)
                    .scaleX(10)
                    .toObject();
            expect(mat).to.eql({x: -20, y: 1, z: 3});
        });

        it("should be composable with translation operations", function() {
            mat = matrix.rotateZ(90)
                    .scaleY(10)
                    .translateX(10)
                    .toObject();

            expect(mat).to.eql({x: 8, y: 10, z: 3});
        });

        it("should be composable with rotation operations", function() {
            mat = matrix.rotateZ(90)
                    .rotateZ(-90)
                    .toObject();

            expect(mat).to.eql({x: 1, y: 2, z: 3});
        });

        it("should rotate about the x axis", function() {
            mat = matrix.rotateX(90).toObject();
            expect(mat).to.eql({x: 1, y: -3, z: 2});
        });

        it("should rotate about the y axis", function() {
            mat = matrix.rotateY(90).toObject();
            expect(mat).to.eql({x: 3, y: 2, z: -1});
        });

        it("should be composable with other rotations", function() {
            mat = matrix
                .rotateX(90)
                .rotateY(90)
                .rotateZ(90)
                .toObject();
            expect(mat).to.eql({x: 3, y: 2, z: -1});
        });
    });

    describe("overall compasability", function() {
        it("should be able to move through transformations in order called", function() {
            mat = matrix.translateX(10) // 11 2 3
                .translateY(-50) // 11 -48 3
                .scaleZ(20) // 11 -48 60
                .rotateZ(90) // 48 11 60
                .rotateX(180) // 48 -11 60
                .scaleY(0.5); // 48 -5.5 -60
            
            expect(mat.toObject()).to.eql({x: 48, y: -5.5, z: -60});
        });
    });

    describe("combined operations", function() {
        it("should take an object of structure {x: i, y: j, z: k} and translate in all three dimensions", function() {
            expect(matrix.translate({x: 2, y: 4, z: -10}).toObject()).to.eql({x: 3, y: 6, z: -7});
        });

        it("should take an object of structure {x: i, y: j, z: k} and scale in all three dimensions", function() {
            expect(matrix.scale({x: 2, y: 4, z: -10}).toObject()).to.eql({x: 2, y: 8, z: -30});
        });

        it("should take an object of structure {x: i, y: j, z: k} and rotate about the X then Y then Z dimensions", function() {
            // around x = swap z and y then negate y
            var testMatrix = new Matrix({x: 1,y: 2,z: 3});
            mat = matrix.rotateXYZ({x: 90, y: 90, z:90}).toObject();
            expect(mat).to.eql(testMatrix.rotateX(90).rotateY(90).rotateZ(90).toObject());
        });

        it("should take an object of structure {x: i, y: j, z: k} and rotate about the Z then Y then X dimensions", function() {
            var testMatrix = new Matrix({x: 1,y: 2,z: 3});
            mat = matrix.rotateZYX({x: 90, y: 90, z: 90}).toObject();
            expect(mat).to.eql(testMatrix.rotateZ(90).rotateY(90).rotateX(90).toObject());
        });
    });

    describe("combination of translation, rotation and scaling about a given origin", function() {
        it("should take 3 objects: translation, scaling, rotation and return the combined transformation assuming origin is 0,0,0", function() {
            mat = matrix.move({x: 10, y: 20, z: 30}, {x: 4, y: 5, z: 6}, {x: 90, y: 90, z:90}).toObject();
            var testMatrix = new Matrix({x: 1, y: 2, z: 3});
            testMatrix = testMatrix.scale({x: 4, y: 5, z: 6}).rotateXYZ({x: 90, y: 90, z:90}).translate({x: 10, y: 20, z: 30}).toObject();
            expect(mat).to.eql(testMatrix);
        });

        it("should take 4 objects: translation, scaling, rotation, and origin and return the combined transformation about the origin", function() {
            mat = matrix.move({x: 10, y: 20, z: 30}, {x: 4, y: 5, z: 6}, {x: 90, y: 90, z:90}, {x: 5, y: 5, z: 5}).toObject();
            var testMatrix = new Matrix({x: 1, y: 2, z: 3});
            testMatrix = testMatrix.translate({x: 5, y: 5, z: 5}).scale({x: 4, y: 5, z: 6}).rotateXYZ({x: 90, y: 90, z:90}).translate({x: -5, y: -5, z: -5}).translate({x: 10, y: 20, z: 30}).toObject();

            expect(mat).to.eql(testMatrix);
        });
    });
});